<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Visualizer</title>
    <link rel="stylesheet" href="style.css">
    <style>/* ============================
   GLOBAL
============================ */
body {
    background: #1e1e1e;
    color: white;
    font-family: Arial;
    text-align: center;
    margin: 0;
    padding: 20px;
}

h1, h2 {
    margin-bottom: 15px;
}

.container {
    display: grid;
    grid-template-columns: 1fr;
    gap: 40px;
    max-width: 1100px;
    margin: auto;
}

/* ============================
   SORTING VISUALIZER
============================ */
#sorting-bars {
    display: flex;
    justify-content: center;
    align-items: flex-end;
    height: 220px;
    gap: 4px;
}

.bar {
    width: clamp(8px, 2vw, 22px);
    background: #4caf50;
    transition: height 0.2s;
}

/* ============================
   SEARCHING VISUALIZER
============================ */
#search-array {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 6px;
}

.cell {
    width: clamp(30px, 8vw, 45px);
    height: clamp(30px, 8vw, 45px);
    background: #444;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: clamp(14px, 3vw, 20px);
    border-radius: 5px;
}

.active {
    background: orange !important;
}
.found {
    background: green !important;
}

/* ============================
   PATHFINDING GRID (FIXED)
============================ */
#grid {
    margin: 20px auto;
    display: grid;
    grid-template-columns: repeat(20, 25px);  /* DEFAULT */
    gap: 2px;
}

.node {
    width: 25px;
    height: 25px;
    background: #555;
}

.wall { background: black !important; }
.start { background: green !important; }
.end { background: red !important; }
.visited { background: #00b7ff !important; }
.path { background: yellow !important; }

.controls {
    margin-top: 10px;
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 10px;
}

button, select, input {
    padding: 8px 12px;
    font-size: clamp(12px, 3vw, 16px);
    border-radius: 5px;
    border: none;
    cursor: pointer;
}

button {
    background: #007bff;
    color: white;
}

button:disabled {
    opacity: 0.5;
}

/* ============================
   RESPONSIVE BREAKPOINTS
============================ */

/* Tablets */
@media (max-width: 768px) {
    #sorting-bars {
        height: 160px;
    }

    #grid {
        grid-template-columns: repeat(20, 18px);
    }

    .node {
        width: 18px;
        height: 18px;
    }
}

/* Mobile */
@media (max-width: 480px) {
    #sorting-bars {
        height: 130px;
    }

    #grid {
        grid-template-columns: repeat(20, 14px);
    }

    .node {
        width: 14px;
        height: 14px;
    }

    button, select, input {
        width: 100%;
        max-width: 300px;
    }
}

</style>
</head>
<body>

<h1>Algorithm Visualizer (Sorting + Searching + Pathfinding)</h1>

<div class="container">

    <!-- Sorting Section -->
    <section>
        <h2>Sorting Visualizer</h2>
        <div id="sorting-bars"></div>

        <div class="controls">
            <button onclick="generateBars()">Generate Array</button>
            <select id="sortAlgo">
                <option value="bubble">Bubble Sort</option>
                <option value="selection">Selection Sort</option>
                <option value="insertion">Insertion Sort</option>
                <option value="merge">Merge Sort</option>
                <option value="quick">Quick Sort</option>
            </select>
            <button onclick="startSort()">Start Sorting</button>
        </div>
    </section>

    <!-- Searching Section -->
    <section>
        <h2>Searching Visualizer</h2>
        <div id="search-array"></div>

        <input id="searchValue" type="number" placeholder="Enter value">
        <select id="searchAlgo">
            <option value="linear">Linear Search</option>
            <option value="binary">Binary Search</option>
        </select>
        <button onclick="startSearch()">Start Search</button>
        <button onclick="generateSearchArray()">Generate Array</button>
    </section>

    <!-- Pathfinding Section -->
    <section>
        <h2>Pathfinding Visualizer</h2>

        <div id="grid"></div>

        <div class="controls">
            <select id="pathAlgo">
                <option value="bfs">BFS</option>
                <option value="dfs">DFS</option>
                <option value="dijkstra">Dijkstra</option>
                <option value="astar">A*</option>
            </select>
            <button onclick="startPathfinding()">Visualize</button>
            <button onclick="resetGrid()">Reset Grid</button>
        </div>
    </section>

</div>

<script>// script.js
// Complete frontend JS for Sorting, Searching and Pathfinding visualizers
// Works with the provided index.html and style.css

/* =========================
   Utilities
   ========================= */
function sleep(ms) {
  return new Promise((res) => setTimeout(res, ms));
}

function randInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

/* =========================
   SORTING VISUALIZER
   ========================= */
let sortArray = [];
const SORT_BARS_CONTAINER = document.getElementById("sorting-bars");

function generateBars(size = 30, min = 10, max = 190) {
  sortArray = Array.from({ length: size }, () => randInt(min, max));
  renderBars();
}

function renderBars() {
  SORT_BARS_CONTAINER.innerHTML = "";
  for (let i = 0; i < sortArray.length; i++) {
    const bar = document.createElement("div");
    bar.className = "bar";
    bar.style.height = `${sortArray[i]}px`;
    bar.dataset.index = i;
    SORT_BARS_CONTAINER.appendChild(bar);
  }
}

async function startSort() {
  const algo = document.getElementById("sortAlgo").value;
  disableAllControls(true);
  switch (algo) {
    case "bubble":
      await bubbleSort(sortArray.slice());
      break;
    case "selection":
      await selectionSort(sortArray.slice());
      break;
    case "insertion":
      await insertionSort(sortArray.slice());
      break;
    case "merge":
      await mergeSort(sortArray.slice());
      break;
    case "quick":
      await quickSort(sortArray.slice());
      break;
  }
  disableAllControls(false);
  // mark all green at end
  const bars = document.querySelectorAll("#sorting-bars .bar");
  for (let b of bars) b.style.background = "green";
}

/* Sorting Algorithms (visualized) */
async function bubbleSort(arr) {
  const bars = document.querySelectorAll("#sorting-bars .bar");
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      // highlight
      bars[j].style.background = "orange";
      bars[j + 1].style.background = "orange";
      await sleep(30);
      if (arr[j] > arr[j + 1]) {
        // swap in array and DOM
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        bars[j].style.height = `${arr[j]}px`;
        bars[j].innerText = "";
        bars[j + 1].style.height = `${arr[j + 1]}px`;
        await sleep(30);
      }
      // reset color
      bars[j].style.background = "#4caf50";
      bars[j + 1].style.background = "#4caf50";
    }
  }
}

async function selectionSort(arr) {
  const bars = document.querySelectorAll("#sorting-bars .bar");
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    let minIdx = i;
    bars[minIdx].style.background = "purple";
    for (let j = i + 1; j < n; j++) {
      bars[j].style.background = "orange";
      await sleep(25);
      if (arr[j] < arr[minIdx]) {
        bars[minIdx].style.background = "#4caf50";
        minIdx = j;
        bars[minIdx].style.background = "purple";
      } else {
        bars[j].style.background = "#4caf50";
      }
    }
    if (minIdx !== i) {
      [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
      bars[i].style.height = `${arr[i]}px`;
      bars[minIdx].style.height = `${arr[minIdx]}px`;
    }
    bars[i].style.background = "green";
    bars[minIdx].style.background = "#4caf50";
  }
  bars[bars.length - 1].style.background = "green";
}

async function insertionSort(arr) {
  const bars = document.querySelectorAll("#sorting-bars .bar");
  for (let i = 1; i < arr.length; i++) {
    let key = arr[i];
    let j = i - 1;
    bars[i].style.background = "orange";
    await sleep(40);
    while (j >= 0 && arr[j] > key) {
      bars[j].style.background = "orange";
      arr[j + 1] = arr[j];
      bars[j + 1].style.height = `${arr[j + 1]}px`;
      await sleep(40);
      bars[j].style.background = "#4caf50";
      j--;
    }
    arr[j + 1] = key;
    bars[j + 1].style.height = `${key}px`;
    await sleep(40);
  }
}

async function mergeSort(arr) {
  const bars = document.querySelectorAll("#sorting-bars .bar");

  async function merge(l, m, r) {
    const left = arr.slice(l, m + 1);
    const right = arr.slice(m + 1, r + 1);
    let i = 0,
      j = 0,
      k = l;
    while (i < left.length && j < right.length) {
      bars[k].style.background = "orange";
      await sleep(25);
      if (left[i] <= right[j]) {
        arr[k] = left[i++];
      } else {
        arr[k] = right[j++];
      }
      bars[k].style.height = `${arr[k]}px`;
      bars[k].style.background = "#4caf50";
      k++;
    }
    while (i < left.length) {
      bars[k].style.background = "orange";
      await sleep(25);
      arr[k] = left[i++];
      bars[k].style.height = `${arr[k]}px`;
      bars[k].style.background = "#4caf50";
      k++;
    }
    while (j < right.length) {
      bars[k].style.background = "orange";
      await sleep(25);
      arr[k] = right[j++];
      bars[k].style.height = `${arr[k]}px`;
      bars[k].style.background = "#4caf50";
      k++;
    }
  }

  async function ms(l, r) {
    if (l >= r) return;
    const m = Math.floor((l + r) / 2);
    await ms(l, m);
    await ms(m + 1, r);
    await merge(l, m, r);
  }

  await ms(0, arr.length - 1);
}

async function quickSort(arr) {
  const bars = document.querySelectorAll("#sorting-bars .bar");

  async function partition(l, h) {
    const pivot = arr[h];
    let i = l - 1;
    bars[h].style.background = "purple";
    for (let j = l; j <= h - 1; j++) {
      bars[j].style.background = "orange";
      await sleep(30);
      if (arr[j] < pivot) {
        i++;
        [arr[i], arr[j]] = [arr[j], arr[i]];
        bars[i].style.height = `${arr[i]}px`;
        bars[j].style.height = `${arr[j]}px`;
      }
      bars[j].style.background = "#4caf50";
    }
    [arr[i + 1], arr[h]] = [arr[h], arr[i + 1]];
    bars[i + 1].style.height = `${arr[i + 1]}px`;
    bars[h].style.height = `${arr[h]}px`;
    bars[h].style.background = "#4caf50";
    return i + 1;
  }

  async function qsort(l, h) {
    if (l < h) {
      const p = await partition(l, h);
      await qsort(l, p - 1);
      await qsort(p + 1, h);
    }
  }

  await qsort(0, arr.length - 1);
}

/* =========================
   SEARCHING VISUALIZER
   ========================= */
let searchArray = [];
const SEARCH_CONTAINER = document.getElementById("search-array");

function generateSearchArray(size = 20, min = 1, max = 99) {
  searchArray = Array.from({ length: size }, () => randInt(min, max));
  renderSearchArray();
}

function renderSearchArray(sorted = false) {
  SEARCH_CONTAINER.innerHTML = "";
  const arr = sorted ? [...searchArray].sort((a, b) => a - b) : searchArray;
  for (let i = 0; i < arr.length; i++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.dataset.index = i;
    cell.innerText = arr[i];
    SEARCH_CONTAINER.appendChild(cell);
  }
}

async function startSearch() {
  const algo = document.getElementById("searchAlgo").value;
  const val = parseInt(document.getElementById("searchValue").value, 10);
  if (isNaN(val)) {
    alert("Enter a valid number to search");
    return;
  }
  disableAllControls(true);
  if (algo === "linear") {
    await linearSearch(val);
  } else {
    // binary search -> sort first
    renderSearchArray(true);
    await sleep(150);
    await binarySearch(val);
  }
  disableAllControls(false);
}

async function linearSearch(target) {
  const cells = document.querySelectorAll("#search-array .cell");
  let found = false;
  for (let i = 0; i < cells.length; i++) {
    cells[i].classList.add("active");
    await sleep(120);
    if (parseInt(cells[i].innerText, 10) === target) {
      cells[i].classList.remove("active");
      cells[i].classList.add("found");
      found = true;
      break;
    } else {
      cells[i].classList.remove("active");
    }
  }
  if (!found) alert("Value not found");
}

async function binarySearch(target) {
  const cells = document.querySelectorAll("#search-array .cell");
  let l = 0,
    h = cells.length - 1;
  let found = false;
  while (l <= h) {
    const mid = Math.floor((l + h) / 2);
    cells[mid].classList.add("active");
    await sleep(120);
    const val = parseInt(cells[mid].innerText, 10);
    if (val === target) {
      cells[mid].classList.remove("active");
      cells[mid].classList.add("found");
      found = true;
      break;
    } else if (val < target) {
      cells[mid].classList.remove("active");
      l = mid + 1;
    } else {
      cells[mid].classList.remove("active");
      h = mid - 1;
    }
  }
  if (!found) alert("Value not found");
}

/* =========================
   PATHFINDING VISUALIZER
   ========================= */
const GRID_CONTAINER = document.getElementById("grid");
const ROWS = 20;
const COLS = 20;
let grid = [];
let startNode = { r: 10, c: 4 };
let endNode = { r: 10, c: 15 };
let isMouseDown = false;
let placingMode = "wall"; // 'wall', 'start', 'end'

function initGrid() {
  GRID_CONTAINER.innerHTML = "";
  GRID_CONTAINER.style.gridTemplateColumns = `repeat(${COLS}, 25px)`;
  grid = [];
  for (let r = 0; r < ROWS; r++) {
    const row = [];
    for (let c = 0; c < COLS; c++) {
      const node = createNode(r, c);
      row.push(node);
      GRID_CONTAINER.appendChild(node.element);
    }
    grid.push(row);
  }
  attachGridHandlers();
  setNodeClass(startNode.r, startNode.c, "start");
  setNodeClass(endNode.r, endNode.c, "end");
}

function createNode(r, c) {
  const el = document.createElement("div");
  el.className = "node";
  el.id = `node-${r}-${c}`;
  el.dataset.r = r;
  el.dataset.c = c;
  return {
    r,
    c,
    isWall: false,
    element: el,
    distance: Infinity,
    heuristic: Infinity,
    previous: null,
    visited: false,
  };
}

function attachGridHandlers() {
  GRID_CONTAINER.onmousedown = (e) => {
    e.preventDefault();
    isMouseDown = true;
    const target = e.target;
    if (!target || !target.id) return;
    const [_, r, c] = target.id.split("-");
    const rr = parseInt(r, 10),
      cc = parseInt(c, 10);
    if (e.shiftKey) {
      // set start
      setStart(rr, cc);
    } else if (e.altKey) {
      // set end
      setEnd(rr, cc);
    } else {
      toggleWall(rr, cc);
    }
  };

  GRID_CONTAINER.onmouseup = () => {
    isMouseDown = false;
  };

  GRID_CONTAINER.onmouseleave = () => {
    isMouseDown = false;
  };

  // drag to draw walls
  GRID_CONTAINER.onmousemove = (e) => {
    if (!isMouseDown) return;
    const target = e.target;
    if (!target || !target.id) return;
    const [_, r, c] = target.id.split("-");
    const rr = parseInt(r, 10),
      cc = parseInt(c, 10);
    if (!isNaN(rr) && !isNaN(cc)) toggleWall(rr, cc, true);
  };

  // disable context menu on grid
  GRID_CONTAINER.oncontextmenu = (e) => {
    e.preventDefault();
  };

  // instructions: click = toggle wall, shift+click = set start, alt+click = set end
}

function setNodeClass(r, c, cls) {
  const node = grid[r][c];
  node.element.className = "node";
  if (cls === "wall") node.element.classList.add("wall");
  if (cls === "start") node.element.classList.add("start");
  if (cls === "end") node.element.classList.add("end");
}

function toggleWall(r, c, onlySet = false) {
  // prevent toggling start/end nodes
  if ((r === startNode.r && c === startNode.c) || (r === endNode.r && c === endNode.c)) return;
  const node = grid[r][c];
  node.isWall = !onlySet ? !node.isWall : true;
  setNodeClass(r, c, node.isWall ? "wall" : "");
}

function setStart(r, c) {
  // clear previous
  setNodeClass(startNode.r, startNode.c, "");
  startNode = { r, c };
  const n = grid[r][c];
  n.isWall = false;
  setNodeClass(r, c, "start");
}

function setEnd(r, c) {
  setNodeClass(endNode.r, endNode.c, "");
  endNode = { r, c };
  const n = grid[r][c];
  n.isWall = false;
  setNodeClass(r, c, "end");
}

function resetGrid() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const n = grid[r][c];
      n.isWall = false;
      n.visited = false;
      n.distance = Infinity;
      n.previous = null;
      n.heuristic = Infinity;
      n.element.className = "node";
    }
  }
  setNodeClass(startNode.r, startNode.c, "start");
  setNodeClass(endNode.r, endNode.c, "end");
}

/* Pathfinding helpers */
function neighborsOf(r, c) {
  const neigh = [];
  if (r > 0) neigh.push(grid[r - 1][c]);
  if (r < ROWS - 1) neigh.push(grid[r + 1][c]);
  if (c > 0) neigh.push(grid[r][c - 1]);
  if (c < COLS - 1) neigh.push(grid[r][c + 1]);
  return neigh;
}

function reconstructPath(end) {
  const path = [];
  let cur = end;
  while (cur) {
    path.unshift(cur);
    cur = cur.previous;
  }
  return path;
}

async function visualizeVisitedOrder(visitedNodes, pathNodes) {
  for (let node of visitedNodes) {
    if ((node.r === startNode.r && node.c === startNode.c) || (node.r === endNode.r && node.c === endNode.c)) continue;
    node.element.classList.add("visited");
    await sleep(18);
  }
  // draw path
  if (pathNodes && pathNodes.length) {
    for (let node of pathNodes) {
      if ((node.r === startNode.r && node.c === startNode.c) || (node.r === endNode.r && node.c === endNode.c)) continue;
      node.element.classList.remove("visited");
      node.element.classList.add("path");
      await sleep(45);
    }
  }
}

async function startPathfinding() {
  const algo = document.getElementById("pathAlgo").value;
  disableAllControls(true);
  // reset metadata
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const n = grid[r][c];
      n.visited = false;
      n.distance = Infinity;
      n.previous = null;
      n.heuristic = Infinity;
      if (!n.isWall) n.element.className = "node";
    }
  }
  setNodeClass(startNode.r, startNode.c, "start");
  setNodeClass(endNode.r, endNode.c, "end");

  const start = grid[startNode.r][startNode.c];
  const end = grid[endNode.r][endNode.c];

  let visitedOrder = [];
  let path = [];

  switch (algo) {
    case "bfs":
      visitedOrder = bfs(start, end);
      path = reconstructPath(end);
      break;
    case "dfs":
      visitedOrder = dfs(start, end);
      path = reconstructPath(end);
      break;
    case "dijkstra":
      visitedOrder = dijkstra(start, end);
      path = reconstructPath(end);
      break;
    case "astar":
      visitedOrder = astar(start, end);
      path = reconstructPath(end);
      break;
  }

  await visualizeVisitedOrder(visitedOrder, path);
  disableAllControls(false);
}

/* BFS */
function bfs(start, finish) {
  const q = [];
  q.push(start);
  start.visited = true;
  const visitedOrder = [];
  while (q.length) {
    const node = q.shift();
    visitedOrder.push(node);
    if (node === finish) return visitedOrder;
    for (let neigh of neighborsOf(node.r, node.c)) {
      if (!neigh.visited && !neigh.isWall) {
        neigh.visited = true;
        neigh.previous = node;
        q.push(neigh);
      }
    }
  }
  return visitedOrder;
}

/* DFS (stack) */
function dfs(start, finish) {
  const stack = [];
  stack.push(start);
  start.visited = true;
  const visitedOrder = [];
  while (stack.length) {
    const node = stack.pop();
    visitedOrder.push(node);
    if (node === finish) return visitedOrder;
    for (let neigh of neighborsOf(node.r, node.c)) {
      if (!neigh.visited && !neigh.isWall) {
        neigh.visited = true;
        neigh.previous = node;
        stack.push(neigh);
      }
    }
  }
  return visitedOrder;
}

/* Dijkstra (all weights = 1) */
function dijkstra(start, finish) {
  // simple priority queue via array (fine for small grid)
  const pq = [];
  start.distance = 0;
  pq.push(start);
  const visitedOrder = [];
  while (pq.length) {
    // pop smallest distance
    pq.sort((a, b) => a.distance - b.distance);
    const node = pq.shift();
    if (node.visited) continue;
    node.visited = true;
    visitedOrder.push(node);
    if (node === finish) return visitedOrder;
    for (let neigh of neighborsOf(node.r, node.c)) {
      if (neigh.isWall) continue;
      const alt = node.distance + 1;
      if (alt < neigh.distance) {
        neigh.distance = alt;
        neigh.previous = node;
        pq.push(neigh);
      }
    }
  }
  return visitedOrder;
}

/* A* */
function heuristic(a, b) {
  return Math.abs(a.r - b.r) + Math.abs(a.c - b.c);
}

function astar(start, finish) {
  const open = [];
  start.distance = 0;
  start.heuristic = heuristic(start, finish);
  open.push(start);
  const visitedOrder = [];
  while (open.length) {
    open.sort((x, y) => (x.distance + x.heuristic) - (y.distance + y.heuristic));
    const node = open.shift();
    if (node.visited) continue;
    node.visited = true;
    visitedOrder.push(node);
    if (node === finish) return visitedOrder;
    for (let neigh of neighborsOf(node.r, node.c)) {
      if (neigh.isWall) continue;
      const tentative = node.distance + 1;
      if (tentative < neigh.distance) {
        neigh.distance = tentative;
        neigh.heuristic = heuristic(neigh, finish);
        neigh.previous = node;
        open.push(neigh);
      }
    }
  }
  return visitedOrder;
}

/* =========================
   Helpers for UI state
   ========================= */
function disableAllControls(disable) {
  const controls = document.querySelectorAll("button, select, input");
  controls.forEach((c) => (c.disabled = disable));
}

/* =========================
   Initial setup
   ========================= */
window.addEventListener("load", () => {
  // Sorting and Searching initial arrays
  generateBars(30, 20, 160);
  generateSearchArray(20, 1, 99);

  // Grid
  initGrid();

  // small UX hint
  const hint = document.createElement("div");
  hint.style.marginTop = "8px";
  hint.style.fontSize = "13px";
  hint.style.opacity = "0.8";
  hint.style.color = "#ddd";
  hint.innerHTML =
    "<b>Grid controls:</b> Click & drag to draw walls. <em>Shift+Click</em> to set START. <em>Alt+Click</em> to set END.";
  document.body.insertBefore(hint, document.querySelector(".container"));
});
</script>
</body>
</html>
